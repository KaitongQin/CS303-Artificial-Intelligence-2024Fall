 ğ‘†1â†ğ‘†2â†âˆ…;
 while ğ‘†1+ğ‘†2 â‰¤ğ‘˜do
 for j = 1 to N:
 dothe following Monte Carlosampling,eachsamplingtocalculatetheh(v)valuefor
 allvertices:
 1. simulate an IC model using seed set ğ¼1â‹ƒğ‘†1, record the activate set ğ‘1and exposure set ğ‘Ÿ1
 2. simulate an IC model using seed set ğ¼2â‹ƒğ‘†2, record the activate set ğ‘2and exposure setğ‘Ÿ2
 3. for each ğ‘£ğ‘– in G:
 3.1 simulate an IC model base on the ğ‘1 and ğ‘Ÿ1, record the ğ‘1_ğ‘£ğ‘–_ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘’ğ‘šğ‘’ğ‘›ğ‘¡and ğ‘Ÿ1_ğ‘£ğ‘–_ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘’ğ‘šğ‘’ğ‘›ğ‘¡
 3.2 simulate an IC model base on the ğ‘2 and ğ‘Ÿ2, record the ğ‘2_ğ‘£ğ‘–_ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘’ğ‘šğ‘’ğ‘›ğ‘¡and ğ‘Ÿ2_ğ‘£ğ‘–_ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘’ğ‘šğ‘’ğ‘›ğ‘¡
 3.3 calculate and record the â„1ğ‘—(ğ‘£ğ‘–) = Î¦ğ‘†1âˆªğ‘£ğ‘– ,ğ‘†2 âˆ’Î¦ğ‘†1,ğ‘†2
 3.4 calculate and record the â„2ğ‘—(ğ‘£ğ‘–) = Î¦ğ‘†1,ğ‘†2âˆªğ‘£ğ‘– âˆ’Î¦ğ‘†1,ğ‘†2
 calculatethe averageâ„1ğ‘ğ‘£ğ‘”(ğ‘£)value and â„2ğ‘ğ‘£ğ‘”(ğ‘£) forallvertices
 ğ‘£1 âˆ—â†argmax ğ‘£
 â„1ğ‘ğ‘£ğ‘”(ğ‘£) ;
 ğ‘£2 âˆ—â†argmax ğ‘£
 â„2ğ‘ğ‘£ğ‘”(ğ‘£) ;
 add the better option between<ğ‘£1 âˆ—,âˆ…>and<âˆ…,ğ‘£2 âˆ—>to <ğ‘†1,ğ‘†2>while respecting the budget
è¯·æ ¹æ®ä¸Šè¿°ä¼ªä»£ç å¯¹æˆ‘çš„ä»£ç è¿›è¡Œä¿®æ”¹
def simulation(G, U1, U2):
    r1 = U1.copy()
    r2 = U2.copy()
    q1 = deque(U1)
    q2 = deque(U2)
    a1, a2 = set(), set() 

    while q1:
        current = q1.popleft()
        a1.add(current)
        for neighbor in G.neighbors(current):
            if np.random.rand() < G[current][neighbor]['weight1'] and (neighbor not in a1):
                q1.append(neighbor)
            r1.add(neighbor)

    while q2:
        current = q2.popleft()
        a2.add(current)
        for neighbor in G.neighbors(current):
            if np.random.rand() < G[current][neighbor]['weight2'] and (neighbor not in a2):
                q2.append(neighbor)
            r2.add(neighbor)

    return r1, r2


def bfs(G, v, weight):
    q = deque()
    r = set()
    a = set()
    q.append(v)
    r.add(v)
    a.add(v)
    while q:
        current = q.popleft()
        a.add(current)
        for neighbor in G.neighbors(current):
            if np.random.rand() < G[current][neighbor][weight] and (neighbor not in a):
                q.append(neighbor)
            r.add(neighbor)
    return r


def greedy_best_first(G, I1, I2, budget):
    S1, S2 = set(), set()
    n = G.number_of_nodes()
    while len(S1) + len(S2) < budget:
        h1 = np.zeros(n)
        h2 = np.zeros(n)
        U1, U2 = I1.union(S1), I2.union(S2)
        for _ in range(3):
            r1, r2 = simulation(G, U1, U2)
            start = len(G.nodes() - (r1 - r2).union(r2 - r1))
            for v in range(1000):
                r1_v = bfs(G, v, 'weight1')
                r1_v = r1_v.union(r1)
                end = len(G.nodes() - (r1_v - r2).union(r2 - r1_v))
                h1[v] += (end - start)

                r2_v = bfs(G, v, 'weight2')
                r2_v = r2_v.union(r2)
                end = len(G.nodes() - (r2_v - r1).union(r1 - r2_v))
                h2[v] += (end - start)
        
        v1 = np.argmax(h1)
        v2 = np.argmax(h2)
        if h1[v1] > h2[v2]:
            S1.add(v1)
            print(h1[v1])
        else:
            S2.add(v2)
            print(h2[v2])
    return S1, S2